# leet[263. 丑数](https://leetcode-cn.com/problems/ugly-number/)



一.原题

给你一个整数 `n` ，请你判断 n`` 是否为 丑数 。如果是，返回 `true` ；否则，返回 `false `。

丑数 就是只包含质因数 `2`、`3` 和 `5` 的正整数。

 

示例 1：

```
输入：n = 6
输出：true
解释：6 = 2 × 3
```


示例 2：

```
输入：n = 8
输出：true
解释：8 = 2 × 2 × 2示例 3：
```

```
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```


示例 4：

```
输入：n = 1
输出：true
解释：1 通常被视为丑数。
```


提示：

- `-231 <= n <= 231 - 1`



二.题要

质因数只有 235 的数字被视为丑数. 给一个数判断它是不是只有 235 这三个质因数.

给一个数, 看它除了 235 还有没有别的因数.





三.题解

1."**丑数**是正整数"

由提示可知, n 是可以小于 0 的, 所以当 n 小于 0 的时候, 可以首先排除.





2.丑数的例子

2.1.一些丑数

```
2的n次方, 3的n次方, 5的n次方
2*3
3*5
2*5
```

2.2一些非丑数

```
2*7
3*7
5*7
```



3.设置一个层级模型

可以不经过但一定要有

```java
while (n%2==0)
	n/=2;
while (n%3==0)
	n/=3;
while (n%5==0)
	n/=5;
if (n == 1)
    return true;
//这样, 当遇到不可整除的时候, 依次经过3和5的整除判断
//如果经过 n = n/因数 得到 1的时候就说明可以被整除, 得到的就是丑数.
//其它情况都属于非丑数
```



设想一下, 假如 7 的倍数依次遇到 %2==0, %3==0, %5==0 不通过的话, 不做任何变化, 最后得到的就是 7.

假如 13 的倍数没有经过这个过滤器的话, 最后得到的也是 13.

同理可得, 17, 19, 23, 27..

如果可以被整除的, 都除商得到 1 了, 不满足整除(因数里不包括这些)的都走别的程序了, 也就是得到其它因数.

由此, 可得, 走 235 能被其中一个或者几个整除的一定都走了这些最后变成了 1.

没有变成 1 的说明因数不包括这些, 有其它的因数.





四.解

```java
class Solution {
    public boolean isUgly(int n) {
        if (n < 1)
            return false;        
        while (n%5 == 0)
            n/=5;
        while (n%2 == 0)
            n/=2;
        while (n%3 == 0)
            n/=3;
        
        return n == 1;        
    }
}
```

执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户



五.认识丑数

1.条件变化型: 让目标值依次经过指定的条件变化集合, 满足条件就作对应的变化. 

最后通过检查结果变化的情况, 判断是否达到或者满足查找的条件, 这样的方式在线性查找中也有使用.

2.丑数, 如果可以整除, 一定整除, 直到不能整除, 得到质因数. 直到质因数经过剩下整除判断后得到还是其它的质因数时, 可以判断, 该数字不是丑数.

> 因为如果是丑数的话, 经过以上这些最后一定变成整除的商了—— 1.
>
> 因数中不包括这些的都绕开了.

3.条件顺序可以调换. 不冲突.