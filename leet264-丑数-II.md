# leet[264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)



一.原题

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和或 5 的正整数。

 

示例 1：

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

示例 2：

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```




提示：

- `1 <= n <= 1690`




二.题要

丑数: 因数最多只有 2, 3, 5 的正整数.

现在给定序号, 输出排在第 n 个位置上的丑数.



三.信息

3.1.它怎么知道是第几个丑数.

```
1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30
```

独白: 打出上面数字的时候, 是从 1 开始逐个加一, 然后看它能不能被 2, 3, 5 它们整除.

接着, 隐约感觉上面的数字是要计算出来的, 于是列出了下面的公式.

```
1
1x2
1x3
2x2
1x5
2x3
2x2x2
3x3
2x5
2x2x3x3
3x5
```

拆成 2, 3, 5 的乘法组合, 但是每次写出一个, 也要判断下一个乘以的数值是不是最贴近前面的, 以免遗漏.

这个"看是不是最贴近前面的"的过程实际上是排序的过程.

因虽然大小相乘没有固定的规律, 但总是 2 3 5 之间相乘的结果.

我是只能分析到这里了



四.题解

```java
class Solution {
    public int nthUglyNumber(int n) {
        int n2 = 0;
        int n3 = 0;
        int n5 = 0;
        int[] dp = new int[n];

        dp[0] = 1;
        for(int i = 1; i < n; i++) {
            int x = dp[n2]*2;
            int y = dp[n3]*3;
            int z = dp[n5]*5;
            dp[i] = Math.min(x, Math.min(y, z));
            if (dp[i] == x)
                n2++;
            if (dp[i] == y)
                n3++;
            if (dp[i] == z)
                n5++;
        }
        return dp[n-1];
    }
}
```

参考: https://leetcode-cn.com/problems/ugly-number-ii/comments/882851



