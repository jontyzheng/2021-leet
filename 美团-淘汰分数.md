# 美团-[淘汰分数](https://www.nowcoder.com/test/question/9c4a4e879b4f49939dfaebea8948f976?pid=28665343&tid=43826759)

[TOC]

#### 一.原题

某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。

但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。

显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。



**输入描述:**

```
输入第一行仅包含三个正整数n,x,y，分别表示参赛的人数和晋级淘汰人数区间。(1<=n<=50000,1<=x,y<=n)
输入第二行包含n个整数，中间用空格隔开，表示从1号选手到n号选手的成绩。(1<=|a_i|<=1000)
```



**输出描述:**

```
输出仅包含一个整数，如果不存在这样的m，则输出-1，否则输出符合条件的最小的值。
```



**输入例子1:**

```
6 2 3
1 2 3 4 5 6
```



**输出例子1:**

```
3
```



#### 二.分析

2.1.题意一句话描述

```
在一个有序的分数数组里, 从中间找一个分数使得左右两边的人数, 都落在[x, y] 区间里.
```

> 这里的有序数组的意思是要找这样的值的话, 先将数组排序会更简单, 所以这里就干脆说"有序数组"了

根据题目说的, 说这样的分数可能有多个, 要找最小的, 其中数组又是"有序"的, 

那么一定会经过从左往右遍历的过程.

###### 转换成数组问题

假设分数是一个数组(有序), 要找出这样的数据项, 也就是要这个值左右两边的元素个数, 满足 `[x,y]`.

换算成表达式可以写成

```
左边的个数 >= x
左边的个数 <= y
右边的个数 >= x
右边的个数 <= y
```

###### 不妨化成身高问题

不妨把这些分数换成一组身高, 有一群按照从低到高的人杵那儿, 如果要他们自己找出这样的身高, 看看它们会怎么找?

它们只能左右看看, 然后从左往后一个个看, 看看有没有刚好到那一个人为止, 诶, 到队首的人数满足上面的表达式, 右边部分的人数也刚好满足上面的表达式.

那么, 就是一个简单的多个布尔值验证的问题了!

###### 注意一种情形

左边的部分不少于 `x`, 可以从第 `x` 个开始(在有序数组中, 那样的元素一定不会出现在 `x` 左边)

注意: 可能有多个身高相同的值, 要保证分数值**分割**, 除了遍历的起点, 还要确保下一个分数是另一个完全不相同的分数值.



#### 三.代码(Java实现)

```java
import java.util.Scanner;
import java.util.Arrays;
public class Main{
 
     public static int find(int[] a, int x, int y) {
        int res = -1;
         Arrays.sort(a);
         //不少于 x 个, 所以从第 x 个分数值开始
         outer:
         for (int i =x-1; i < a.length; i++) {
             int tmpScore = a[i];
             //找到下一个不相同的分数值的位置
             int k = x+1;
             while (k < a.length && a[k] == a[i]) 
                 k++;
             //当 k 的跳出值为第 n-1 个时, 说明后面完全相同, 那样情形可以首先排除
             if (k == a.length)
                 return res;
             //比较前半部分和后半部分的要求
             if (k <= y && (a.length-k+1) >= x && (a.length-k) <= y) {
                  res = tmpScore;
                  break;  
             }                  
         }         
         return res;
    }
    
    public static void main(String[] args) {
        Scanner sn = new Scanner(System.in);
        int n = sn.nextInt();
        int x = sn.nextInt();
        int y = sn.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sn.nextInt();
        }
        System.out.println(find(a, x, y));
    }
}
```



结果

```
您的代码已保存
答案正确:恭喜！您提交的程序通过了所有的测试用例
```



注意

```
k代表下一个与起点不相同的分数值
所以 k 前面的 0~k-1 个位为前半部分
从 k 开始后面的元素个数为后半部分, 后半部分的个数表达式是 n-k+1
```

