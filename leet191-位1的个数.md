# leet[191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

[TOC]

#### 一.题目

```
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
 

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 

提示：

输入必须是长度为 32 的 二进制串 。
 

进阶：

如果多次调用这个函数，你将如何优化你的算法？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/number-of-1-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```



#### 二.内容概要

求一个二进制表示的数里面有几个 1

##### 技巧

这种和位数上的字面值有关的题目, 用更新计数法.

> 更新计数法: 
>
> 条件计数和更新.
>
> 每一次在达到目标变化时计数器加一, 然后更新数字, 下一次重复该操作.
>
> 每次对当前位数上的数字判断.



##### **提示：**

- 输入必须是长度为 `32` 的 **二进制串** 。



##### 条件计数

条件: 找到 1 的情况.

用位运算符 `&` 按位与.

按位与: (&), 只有 2 个同时为 1 时才为 1.

可以将这段长长的数值每次都和 1 作 & 判断, 看是否匹配到 1. 是则记录起来(只有 1 & 1 等于 1).

因为每次 1 都是占 1 位, 所以每次 1 都是和这段长数的最后一位作一对一地的按位与匹配.



(然后再更新数值, 让每次 1 都剩下的部分作匹配)



##### 更新

因为以 0 开头的数值会被识别成八进制数值



参数是一个 int 类型的. 因为 int 有 4 种表示格式(二进制, 八进制, 十进制, 十六进制)

八进制表示即用 `0` 开头的, 所以会识别为八进制的数字.

```java
package chap3.no4;

/**
 * @name  ByteTest
 * @layer chap3.no7
 * @intro	验证 0 开头的数字会输出什么值
 * @function
 * */
public class ByteTest {
	public static void main(String[] args) {
		int a = 00000000000000000000000000001011;	//会被当作 8 进制
		System.out.println(a); 	//521
	}
}
```

所以不能使用十进制的方式更新数值.

按位右移: (>>), 对内存里的二进制作移动(>>=). 每次减少长数的位数, 保证下一次和 1 匹配的是左边一位.



#### 三.分析

##### 解法

```
已知参数的位数总是 32 位, 所以可以用这个作判断的标准, 每次位数减一
	if 和 1 按位与匹配得到 1 
		更新计数器
	else
		不更新计数器
	更新参数 n >>= 1
```



#### 四.解

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
                
        int cnt = 0;
        int i = 0;
        while (i < 32) {                       
            //
            if ((n & 1) == 1) {
                cnt++;
            }                
            n >>= 1;
            i++;
        }
        return cnt;
    }
}
```

执行 1 ms, 内存占用 35.5 MB



#### 五.实验分析

二进制的数值用二进制运算解.



#### 六.认识位运算符

1.`&` 只有两个 1 相同时等于 1, 当只有一个数, 可以拿出一个 1 和它作按位与运算, 这样能够判断对方有多少个 1.

2.`>>` 有每次控制小数点右移达到缩减位数的功效.

3.这一道题是看到下面这个评论然后得到的灵感.

https://leetcode-cn.com/problems/number-of-1-bits/comments/826517