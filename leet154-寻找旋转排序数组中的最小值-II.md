# leet[154. 寻找旋转排序数组中的最小值-II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)



一.原题

已知一个长度为 n 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：
若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
若旋转 `7` 次，则可以得到` [0,1,4,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 重复 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

 

示例 1：

```
输入：nums = [1,3,5]
输出：1
```

示例 2：

```
输入：nums = [2,2,2,0,1]
输出：0
```

提示：

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 原来是一个升序排序的数组，并进行了 1 至 n 次旋转



二.题要

同样, 给出一个已知旋转的升序数组, 查询其中最小的数字

不同的是, 这里的数组允许重复.



三.题解

和前面相同的题目, 不同的是, 这里的数组不再是互不相同的元素, 也就是升序后不再是线性上升(旋转前), 有可能是先上升, 后平行, 再上升的趋势.

但是, 不变的是, 旋转依然会破坏原来的顺序.

根据旋转的原理, 到某个位置开始, 把后面的数字调到前面去.

那么, 在后半部分调到前面后, 最后一个开始往后, 便是原来最小的数字.

即, 遍历数组时发现前一个忽然大于后一个的时候, 后面的那个数字, 便是原来的第一位, 也就是最小数字.



四.解

```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        if (n == 1)
            return nums[0];
        for (int i = 0; i < n-1; i++) {
            if (nums[i] > nums[i+1])
                return nums[i+1];
        }
        return nums[0];
    }
}
```



五.认识旋转数组

还是从断层的地方开始找破坏.