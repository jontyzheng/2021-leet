# leet[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

### 一.题目

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7] `在变化后可能得到：
若旋转 `4` 次，则可以得到` [4,5,6,7,0,1,2]`
若旋转 `7 `次，则可以得到` [0,1,2,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组`[a[n-1], a[0], a[1], a[2], ..., a[n-2]] `。

给你一个元素值 互不相同 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。



示例 1：

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

示例 2：

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```


示例 3：

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```


提示：

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 互不相同
- `nums` 原来是一个升序排序的数组，并进行了 1 至 n 次旋转



### 二.题要

旋转数组, 从第几个位置开始, 后面的数组搬到前面了. 

比如: 

```
[1, 2, 3 ,4] 旋转 2 次后的数组是 [3, 4, 1, 2]
```

现在有一个本来排好序的数组, 元素互不相同(本来是一路从头大到尾的), 在某个地方被旋转了求其中最小的元素.



### 三.题解

原本排好序的数组, 元素互不相同, 旋转前, 最小的就是第一个元素.

但是被某个地方给打断了, 打断了的结果就是, 原来从小到大排列的, 忽然在某个地方断层了, 断层的地方一定不再满足 `nums[i] < nums[i+1]`.

找到那个位置, 后一个 `nums[i+1]` 就是那个冒充更大值的最小值.

如果大小顺序没变, 说明没有旋转, 或者刚好旋转的位置等于数组的长度, 等于没旋转过, 那么返回第一个值.



### 四.解

```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;        
        if (n == 1)
            return nums[0];
        for (int j = 0; j < nums.length-1; j++) {
            if (nums[j] > nums[j+1]) {
                return nums[j+1];
            }
        }
        return nums[0];
    }
}
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户



### 五.认识旋转数组

旋转数组经过第一次遇到之后, 就变得很形象了.

这次放在没有重复元素的升序数组后, 效果就更加明显了, 断层的地方一定会破坏原来的升序关系.