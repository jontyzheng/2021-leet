# leet[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

[TOC]

#### 一.题目

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

<img src="D:\桌面传送\markdown文档收录\leet100\img\rotate1.jpg" style="zoom: 67%;" />

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**



<img src="D:\桌面传送\markdown文档收录\leet100\img\roate2.jpg" style="zoom:67%;" />

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`



#### 二.提要

```
假如给的链表是[1, 2, 3, 4, 5]
现在给的数字是 k = 2
返回的链表变成[4, 5, 1, 2, 3]
```



#### 三.理解

这种变化既像是把 [4 - 5] ↶ 调到前面去 , 也像是把 [1 - 2 - 3] ↷ 调到后面去.

<mark>操作链表的关键是获取引用</mark>

`[1, 2, 3, 4, 5]`

如果可以将链表往后<abbr title="#">卷成一个圈</abbr>, 然后在新的位置重新定一个头节点, 最后切断前一个节点的引用就好了.



##### 链表首尾相连

```java
public void circle(ListNode head) {
    ListNode tmp = head;
    while (tmp.next != null) {
        tmp = tmp.next;
    }
    //tmp 指向了尾巴节点
    tmp.next = head;
    //首尾相连
}
```



##### 新的头节点

```
[1, 2, 3, 4, 5]

[[4, 5], [1, 2, 3]

k = 2
```

操作链表的关键是获取引用.

新头节点可以让指向尾巴位置的 `tmp` 循环赋值.

指向新头节点的前一个时, 将下一个引用给新结点, 自己的下一个引用指向空, 先后完成新节点 & 切环 2 种效果.

###### 先定操作, 后定次数

操作: `tmp = tmp.next`

```
[1, 2, 3, 4, 5]

[[4, 5], [1, 2, 3]]
```

次数: 最后是要 `tmp` 从 `5` 指到 `3`, 实际上也可以理解为需要执行 3 次.

条件: `cnt - k` 

```java
//上一步的 tmp 此时指向 5
for (int i = 0; i < cnt - k; i++) {
	tmp = tmp.next;
}
```

`tmp` 指向了 `3 `, 新节点 `4` 的前一位.

```java
ListNode newHead = tmp.next;
tmp.next = null;

return newHead;
```



#### 四.链

这一期认识链表还是比较多一点的.

因为和链表的长度有关. 这一题计算了链表的长度.

从计数的过程中学到了链表长度的计算机制.

然后也知道了注意计算完长度后临时结点指向的位置, 虽然是指向了最后一个结点. 但是拿到最后一个结点的引用对链表来说相当有用. 

链表首尾相连就是尾巴结点的下一个指针域指向头结点, 代码实现也很简单 `tmp.next = head`

然后就是在已经连接成环的链表中任意取头节点的环节了.

确定头节点, 也要知道实际上是想要让 `结点赋值` 执行多少次, 知道执行多少次才能确定循环条件怎么写.

最后两句话.

拿到新头节点前一个结点引用就可以拿到新头节点.

拿到新头节点的前一个引用就可以切断首尾相连.

还是增长了许多对链表的认识.

```
链表是怎么计算长度的?
链表计算完长度头节点会指向哪里?
链表是如何从单链表变成环状链表的?
怎么获取环链中任意一个结点?
怎么切断环链得到一个新链?
```

总的来说, 是一个链的故事.