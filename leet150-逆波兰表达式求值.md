# leet[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

[TOC]

#### 一.题目

```
根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
 

示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
 

提示：

1 <= tokens.length <= 104
tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数
 

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```



#### 二.内容概要

写一个程序计算后缀表达式.

##### 后缀表达式的概念和运算

后缀表达式的格式就是 将原来的 $1+1$ 写成 `1 1 +` , 将原来的 $(1+1)*3$ 写成 `1  1 + 3 *`.

> 操作数挨着运算符
>
> 计算时因为只有 2 个操作数的四则运算. 
>
> 总是先弹出最近的操作数作为第二个操作数, 下一个更近的作为第一个操作数.

像 $(1+1)/3$ 写成后缀表达式就是 `1 1 + 3 /`

运算规则就是

> 遇到 + 时, 将前面的 1 和 1 作为操作数, 得到 2, 接着式子会变成 2 3 /, 
>
> 遇到 / 时, 将前面的 3 作为除数, 2 作为被除数, 得到 2/3 和原来的常规写法一致.

为什么会强调最近的作为第二个操作数呢?

因为这里, 已知最近的数字就是接着运算符的操作数, 当遇到这样对顺序敏感的运算符时, 便需要确定顺序了. 于是后缀表达式规定, 将邻近的一个操作数作为第二个操作数, 往前一个作为第一个操作数.



#### 三.分析

##### 程序解法

在程序中, 栈就是专门用来处理这一问题的.

先进先出, 弹出的总是最新压进的. 如果将数字一一压栈, 当遇到操作符时, 便弹出一个作为第二操作数, 接着弹出一个作为第一操作数. 计算结果得出后重新入栈, 作为下一次弹出的第二操作数.



##### 解法

```
扫描
	-当遇到数字时, 压栈
	-当遇到运算符号时, 从栈中取出一个作为 op2, 弹出下一个作为 op1, 运算后结果入栈
	 直到整个字符串扫描完毕, 栈中剩下的数字即最后的结果.
```





##### 已知

1.`给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。`

> 说明不用考虑给定后缀表达式不规范的情况. 表达式总是规范的, 最后总是会得到 1 个数字, 那个数字便是最后结果.

2.`1 <= tokens.length <= 104`

> 长度大于等于 1, 不需考虑扫描遇到空的情况

3.`1 <= tokens.length <= 104	`

`tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数`

> 没有括号, 不需考虑括号的情况.



##### 需要解决的其它问题

a.扫描都是字符串的形式, 怎么讲数字型的字符串转换成数值

```
int iVal = Integet.parseInt("111");
或者
int iVa; = Integer.valueOf("111");
```

b.符号也是字符串的, 不能直接用于计算

```
匹配 + - * / 后进行对应的操作.
	4 种处理逻辑
```

c.如何区别数字和符号, 然后决定应该压栈还是取出计算后压栈

```java
//
public boolean isNumber(String token) {
    //排除掉所有符号就是数字了
    return !((token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/")));
}
```



#### 四.解

```java
class Solution {
    //新建并实例化一个栈, 用于数字压栈
    Stack<Integer> stack = new Stack<Integer>();

    //判断扫描字符串是否为数字
    public boolean isNumber(String s) {        
        return !("*".equals(s) || "+".equals(s) || "-".equals(s) || "/".equals(s));     //一样不沾为数字      
    }
    
    public int evalRPN(String[] tokens) {
                
        int tLen = tokens.length;

        for (int i = 0; i < tLen; i++) {
            String s = tokens[i];           
            //返回 true 处理压栈
            if (isNumber(s)) {                                
                //压栈
                stack.push(Integer.parseInt(s));
            }

            else {
                //定义 4 种处理逻辑 + - * /
                //做运算必须要从栈中取出操作数, 所以统一提到前面来
                int op2 = (Integer)stack.pop();  //先弹出者作 op2                
                int op1 = (Integer)stack.pop();                

                switch (s) {
                    case "+" : 
                    {                                                
                        stack.push(op1 + op2);
                        break;
                    }
                    case "-":
                    {                           
                        stack.push(op1 - op2);
                        break;
                    }
                    case "*":
                    {                                                
                        stack.push(op1 * op2);
                        break;
                    }
                    case "/":
                    {                                               
                        stack.push(op1 / op2);
                        break;
                    }
                    default:
                }                
            }            
        }
        //tokens 遍历结束
        return (Integer)stack.pop();
    }
}
```

运行 7 ms, 占用 38.4 M 内存





#### 五.实验分析

提前了解后缀表达式有好处



#### 六.认识逆波兰表达式

1.字符串扫描时因为 == 不如 equals(), 所以会遇到说遇到 + 无法进行压栈的情况.(栈设为整数类型);

2.`switch-case` 搭配 break 使用

3.数字型字符串转数值的方法有 `Integer.valueOf()` 也可以官方答案里的 `Integer.parseInt()`

参考: [Java中Integer和int之间的转换](https://blog.csdn.net/jisuanjiguoba/article/details/80235388)

4.`String[] tokens` 是字符串类型的项, 但 `tokens` 还是数组类型的, 数组长度中 length 为自带属性.

